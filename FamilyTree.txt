;;;; -*- Mode:LISP; -*-
;;;; Family Tree program

(defstruct person
	name
	spouse
	parents
	children
)
( setf FamilyTree (make-hash-table :test 'equal))

;;; Hard coding file path for now
;;; Note: Change this path to the absolute path of the test file you wish to run
(setf inputFile (open "~/lispFamilyTree/testFiles/tryingWQuery.txt"))

;;; Get the spouses of the person
(defun getSpouses(p)
  (setf spouses (loop for spouse in (person-spouse (gethash p FamilyTree))
                      collect spouse)))

;;; Get the parents of the person
(defun getParents(p)
	(setf parents (loop for parent in (person-parents (gethash p FamilyTree))
		collect parent)))

;;; Get the siblings of the person
(defun getSiblings(p)
	(setf siblings (remove p (intersection 
		(loop for child in (person-children (gethash (first (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)
		(loop for child in (person-children (gethash (second (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)))))

;;; Get the half siblings of the person
(defun getHalfSiblings(p)
	(setf siblings (union (set-difference
		(loop for child in (person-children (gethash (first (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)
		(loop for child in (person-children (gethash (second (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child))
                             (set-difference
		(loop for child in (person-children (gethash (second (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)
		(loop for child in (person-children (gethash (first (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)))))

;;; Get cousins
;(defun getCousins (p deg rem)
		


;;; Get ancestors   TEST THIS
(defun getAncestors (human)
	(if (not (person-parents human))
	nil)
	(union (getAncestors(first (person-parents human))) (getAncestors(second (person-parents human))) (person-parents human)))


;;; returns list of lists where sub list: name, depth
(defun getAncestorsDeep (p n)
	(if (null(person-parents p))
	nil)
	(union (union(getAncestorsDeep(first(person-parents p)) (+ n 1))
		(getAncestorsDeep(second(person-parents p)) (+ n 1)))	
	(list (list(first(person-parents p))(+ 1 n)
	(list (second(person-parents p)) (+ n 1))))))


;(defun getCousinLevel (human1 human2)
;  (let ((all nil) (common nil) (p1a nil) (p2a nil)))
;    (setf p1a (getAncestorsDeep human1))
;    (setf p2a (getAncestorsDeep human2))
;    (setf common (intersection (getAncestors human1) (getAncestors human2))) 
;    (when (not (null common))
;
;    (loop for i in common  doing
;          (let(( t1 nil) (t2 nil) (t3 nil))
;            (setf t1 (first (member i p1a :key#'first)))
;            (setf t2 (first (member i p2a :key#'first)))
;          
;            ;;;store in t3 s running tally of closest_ ancestor, its_source, removal, degree CHECK THESE:
;
;            (if (< (second t1)  (second t2))
;                      (setf t3 (append  t2 (list human2) (list - (second t2) (second t1)) (list (second t1 )))))
;                 
;            (if (>(second t1)  (second t2)))
;                     (setf t3 (append  t1 (list human1) (list - (second t1) (second t2)) (list (second t2 )))))))  
 
;;;last line which will return the cousin degree rem
;;; (list 'cousin __degree __removal)
          
                
               
	
;;; remove parents from common ancestor lists
;;; 

;(defun getDescendantsDeep (p n)
;	(setf descendants(vector nil))  ;;; trying to create a list to append to after each recursive call
;	
;	(if (not (person-children p))
;	nil)
;	(loop for theperson in (person-children p)
;		(append descendants person-children theperson)


;;; Handle the E query
(defun E(p1 p2 &optional c)
	;;; See if the first parent exists and add them if they do not
	(if (not (gethash p1 FamilyTree))
		(setf firstperson (make-person :name p1 :spouse '() :children '()))
		(setf firstperson (gethash p1 FamilyTree)))
	;;; See if the second parent exists and add them if they do not
	(if (not (gethash p2 FamilyTree))
		(setf secondperson (make-person :name p2 :spouse '() :children '()))
		(setf secondperson (gethash p2 FamilyTree)))
	;;; Add the spouses
	(if (not(find p2 (person-spouse firstperson)))
		(setf (person-spouse firstperson) (append (person-spouse firstperson) (list p2))))
	(if (not(find p1 (person-spouse secondperson)))
		(setf (person-spouse secondperson) (append (person-spouse secondperson) (list p1))))
	;;; Add the child if they exist
	(if (and (not(null c)) (not(gethash c FamilyTree)))
		(progn (setf child (make-person :name c :parents (list p1 p2)))
			(setf (person-children firstperson) (append (person-children firstperson) (list c)))
			(setf (person-children secondperson) (append (person-children secondperson) (list c))))
          (if (gethash c FamilyTree)
              (setf child (gethash c FamilyTree))))
	;;; Add all the people to the hashtable
	(if (not (gethash p1 FamilyTree))
		(setf (gethash p1 FamilyTree) firstperson))
	(if (not (gethash p2 FamilyTree))
		(setf (gethash p2 FamilyTree) secondperson))
	(if (not (gethash c FamilyTree))
		(setf (gethash c FamilyTree) child)))

;;; Handle the W query
(defun W(r p deadVar)
  ;;; Handle spouse query
  (if (string= r "SPOUSE")
      (loop for theperson in (sort (getSpouse p) #'string-lessp)
            do (print theperson)))
  ;;; Handle parent query
  (if (string= r "PARENT")
      (loop for theperson in (sort (getParents p) #'string-lessp)
            do (print theperson)))
  ;;; Handle sibling query
  (if (string= r "SIBLING")
      (loop for theperson in (sort (getSiblings p) #'string-lessp)
            do (print theperson)))
  ;;; Handle half-sibling query
  (if (string= r "HALF-SIBLING")
      (loop for theperson in (sort (getHalfSiblings p) #'string-lessp)
            do (print theperson)))
  ;;; Handle the ancestor query
  (if (string= r "ANCESTOR")
      (loop for theperson in (sort (getAncestors p) #'string-lessp)
            do (print theperson))))

;;; Handle X query
(defun X(p1 r p2)
  ;;; Handle spouse query
  (if (string= r "SPOUSE")
      (if (member p1 (getSpouses p2))
          (print "YES")
        (print "NO")))
  ;;; Handle parent query
  (if (string= r "PARENT")
      (if (member p1 (getParents p2))
          (print "YES")
        (print "NO")))
  ;;; Handle sibling query
  (if (string= r "SIBLING")
      (if (member p1 (getSiblings p2))
          (print "YES")
        (print "NO")))
  ;;; Handle half-sibling query
  (if (string= r "HALF-SIBLING")
      (if (member p1 (getHalfSiblings p2))
          (print "YES")
        (print "NO")))
  ;;; Handle the ancestor query
  (if (string= r "ANCESTOR")
      (if (member p1 (getAncestors p2))
          (print "YES")
        (print "NO"))))

;;; Handle R query
(defun R(p1 p2 deadVar)
  ;;; Handle spouse query
  (if (member p1 (getSpouses p2))
      (print "SPOUSE"))
  ;;; Handle parent query
  (if (member p1 (getParents p2))
      (print "PARENT"))
  ;;; Handle sibling query
  (if (member p1 (getSiblings p2))
      (print "SIBLING"))
  ;;; Handle half-sibling query
  (if (member p1 (getHalfSiblings p2))
      (print "HALF-SIBLING"))
  ;;; Handle the ancestor query
  (if (member p1 (getAncestors p2))
          (print "ANCESTOR")))
	
;;; Handle the various queries
;;; Cannot figure out how to call line from file as a function
;;; This should happen below
(defun processFile()
	(loop for line = (read inputFile nil)
		while line
		do (funcall (first line) (second line) (third line) (fourth line))))

;;; Run the process
(processFile)

;;; Count of how many are in hashtable to see if they were really added
(print "The count of people in the hash table is ")
(print (hash-table-count FamilyTree))
