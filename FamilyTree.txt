;;;; Family Tree program

(defstruct person
	name
	spouse
	parents
	children
)
( setf FamilyTree (make-hash-table :test 'equal))

;;; Creates person "Bill" and "Jim" and puts them in hashtable FamilyTree (Jim is the parent of Bill)
;;; (setf personTemp (make-person :name "Bill" :parents "Jim"))
;;; (setf (gethash "Bill" FamilyTree) personTemp)
;;; (setf personTemp (make-person :name "Jim"))
;;; (setf (gethash "Jim" FamilyTree) personTemp)

;;; Access Bill or Jim
;;; (gethash "Bill" FamilyTree)
;;; (gethash "Jim" FamilyTree)

;;; Hard coding file path for now
;;; Note: Change this path to the absolute path of the test file you wish to run
(setf inputFile (open "~/lispFamilyTree/testFiles/tryingWQuery.txt"))

;;; Get the parents of the person
(defun getParents(p)
	(setf parents (loop for parent in (person-parents (gethash p FamilyTree))
		collect parent)))

;;; Get the siblings of the person
(defun getSiblings(p)
	(setf siblings (remove p (union 
		(loop for child in (person-children (gethash (first (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)
		(loop for child in (person-children (gethash (second (person-parents (gethash p FamilyTree))) FamilyTree))
			collect child)))))


;;; Get cousins
;(defun getCousins (p deg rem)
		


;;; Get ancestors   TEST THIS
(defun getAncestors (human)
	(if (not (person-parents human))
	nil)
	(union (getAncestors(first (person-parents human))) (getAncestors(second (person-parents human))) (person-parents human)))
	
(defun getAncestorsDeep (p n)
	(if (not(person-parents p))
	nil)
	(union (union(getAncestorsDeep(first(person-parents p)) (+ n 1))
		(getAncestorsDeep(second(person-parents p)) (+ n 1)))	
	(list (list(first(person-parents p))n) ;I think this combines the two lists in to one and then "returns" it
	(list (second(person-parents p)) n))))
	
;;; assuming when you union two ancestor lists, the earliest common ancestor will be the first item?

;;; opposite of getAncestorsDeep
;(defun getDescendantsDeep (p n)
;	(setf descendants(vector nil))  ;;; trying to create a list to append to after each recursive call
;	(if (not (person-children p))
;	nil)
;	(loop for theperson in (person-children p)
		


;;; Handle the E query
(defun E(p1 p2 &optional c)
	;;; See if the first parent exists and add them if they do not
	(if (not (gethash p1 FamilyTree))
		(setf firstperson (make-person :name p1 :spouse '() :children '()))
		(setf firstperson (gethash p1 FamilyTree)))
	;;; See if the second parent exists and add them if they do not
	(if (not (gethash p2 FamilyTree))
		(setf secondperson (make-person :name p2 :spouse '() :children '()))
		(setf secondperson (gethash p2 FamilyTree)))
	;;; Add the spouses
	(if (not(find p2 (person-spouse firstperson)))
		(setf (person-spouse firstperson) (append (person-spouse firstperson) (list p2))))
	(if (not(find p1 (person-spouse secondperson)))
		(setf (person-spouse secondperson) (append (person-spouse secondperson) (list p1))))
	;;; Add the child if they exist
	(if (and (not(null c)) (not(gethash c FamilyTree)))
		(progn (setf child (make-person :name c :parents (list p1 p2)))
			(setf (person-children firstperson) (append (person-children firstperson) (list c)))
			(setf (person-children secondperson) (append (person-children secondperson) (list c)))))
	;;; Add all the people to the hashtable
	(if (not (gethash p1 FamilyTree))
		(setf (gethash p1 FamilyTree) firstperson))
	(if (not (gethash p2 FamilyTree))
		(setf (gethash p2 FamilyTree) secondperson))
	(if (not (gethash c FamilyTree))
		(setf (gethash c FamilyTree) child))
	(print firstperson))

;;; Handle the W query
(defun W(r p deadVar)
	;;; Handle parent query
	(if (string= r "PARENT")
		(loop for theperson in (getParents p)
			do (print theperson)))
	(if (string= r "SIBLING")
		(loop for theperson in (getSiblings p)
			do (print theperson))))

;;; Handle the various queries
;;; Cannot figure out how to call line from file as a function
;;; This should happen below
(defun processFile()
	(loop for line = (read inputFile nil)
		while line
		do (funcall (first line) (second line) (third line) (fourth line))))

;;; Run the process
(processFile)

;;; Count of how many are in hashtable to see if they were really added
(print "The count of people in the hash table is ")
(print (hash-table-count FamilyTree))
