;;;; Family Tree program

(defstruct person
	name
	spouse
	parents
	children
)
( setf FamilyTree (make-hash-table :test 'equal))

;;; Creates person "Bill" and "Jim" and puts them in hashtable FamilyTree (Jim is the parent of Bill)
;;; (setf personTemp (make-person :name "Bill" :parents "Jim"))
;;; (setf (gethash "Bill" FamilyTree) personTemp)
;;; (setf personTemp (make-person :name "Jim"))
;;; (setf (gethash "Jim" FamilyTree) personTemp)

;;; Access Bill or Jim
;;; (gethash "Bill" FamilyTree)
;;; (gethash "Jim" FamilyTree)

;;; Hard coding file path for now
;;; Note: Change this path to the absolute path of the test file you wish to run
(setf inputFile (open "~/lispFamilyTree/testFiles/tryingWQuery.txt"))

;;; Get the parents of the person
(defun getParents(p)
	(progn (setf parents '())
		(setf theperson (gethash p FamilyTree))
		(loop for parent in (person-parents theperson)
		do (progn (setf parentObj (gethash parent FamilyTree))
		(append parents parentObj)))))

;;; Get the siblings of the person
;(defun getSiblings(p)
;	(setf siblings (list ()))
;	(let (setq person (gethash p FamilyTree)
;		if (not(null (first (person-parents)))
;			append(siblings (first (person-parents))-children)
;		if (not(null (second (person-parents)))
;			append(siblings (second (person-parents))-children)
;		siblings))


;;; Get cousins
(defun getCousins (p deg rem)
		


;;; Get ancestors   TEST THIS
(defun getAncestors (human)
	(if (not (person-parents human))
	nil)
	(union (getAncestors(first (person-parents human))) (getAncestors(second (person-parents human))) (person-parents human)))
	
(defun getAncestorsDeep (p n)
	(if (not(person-parents p))
	nil)
	(union (union(getAncestorsDeep(first(person-parents p)) (+ n 1))
		(getAncestorsDeep(second(person-parents p)) (+ n 1)))	
	(list (list(first(person-parents p))n) ;I think this combines the two lists in to one and then "returns" it
	(list (second(person-parents p)) n))))
	
;;; assuming when you union two ancestor lists, the earliest common ancestor will be the first item?

;;; opposite of getAncestorsDeep
(defun getDescendantsDeep (p n)
	(setf descendants(vector nil))  ;;; trying to create a list to append to after each recursive call
	(if (not (person-children p))
	nil)
	(loop for theperson in (person-children p)
		


;;; Handle the E query
(defun E(p1 p2 &optional c)
	;;; See if the first parent exists and add them if they do not
	(if (not (gethash p1 FamilyTree))
		(setf firstperson (make-person :name p1 :spouse '()))
		(setf firstperson (gethash p1 FamilyTree)))
	;;; See if the second parent exists and add them if they do not
	(if (not (gethash p2 FamilyTree))
		(setf secondperson (make-person :name p2 :spouse '()))
		(setf secondperson (gethash p2 FamilyTree)))
	;;; Add the spouses
	(append (person-spouse firstperson) p2)
	(append (person-spouse secondperson) p1)
	;;; Add the child if they exist
	(if (not(gethash c FamilyTree))
		(setf child (make-person :name c :parents (list p1 p2)))
		(progn (setf (person-children firstperson) c)
			(setf (person-children secondperson) c)))
	;;; Add all the people to the hashtable
	(if (not (gethash p1 FamilyTree))
		(setf (gethash p1 FamilyTree) firstperson))
	(if (not (gethash p2 FamilyTree))
		(setf (gethash p2 FamilyTree) secondperson))
	(if (not (gethash c FamilyTree))
		(setf (gethash c FamilyTree) child)))

;;; Handle the W query
(defun W(r p deadVar)
	;;; Handle parent query
	(if (string= r "PARENT")
		(loop for theperson in (getParents p)
			do (print (person-name theperson)))))

;;; Handle the various queries
;;; Cannot figure out how to call line from file as a function
;;; This should happen below
(defun processFile()
	(loop for line = (read inputFile nil)
		while line
		do (funcall (first line) (second line) (third line) (fourth line))))

;;; Run the process
(processFile)

;;; Count of how many are in hashtable to see if they were really added
(print "The count of people in the hash table is ")
(print (hash-table-count FamilyTree))
